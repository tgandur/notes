{"version":3,"file":"printer.js","names":["line","listItems: string[][]","docs: Doc[]","wordDocs: Doc[]","parts: Doc[]","paragraphLines: string[]","typeTerms: Doc[]","printer: ThaloPrinter"],"sources":["../src/printer.ts"],"sourcesContent":["import type { AstPath, Doc, Options, Printer } from \"prettier\";\nimport type { SyntaxNode } from \"tree-sitter\";\nimport { doc } from \"prettier\";\nimport type { ThaloRootNode } from \"./parser\";\n\nconst { align, fill, hardline, join, line } = doc.builders;\n\ntype ThaloPrinter = Printer<SyntaxNode>;\n\ntype ThaloOptions = Options & {\n  proseWrap?: \"always\" | \"never\" | \"preserve\";\n};\n\nconst getIndent = (options: ThaloOptions): string => {\n  const tabWidth = typeof options.tabWidth === \"number\" ? options.tabWidth : 2;\n  return options.useTabs ? \"\\t\" : \" \".repeat(tabWidth);\n};\n\n/**\n * Detect markdown list items: \"- item\", \"* item\", \"+ item\", \"1. item\", etc.\n */\nconst isListItem = (line: string): boolean => {\n  return /^[-*+]\\s|^\\d+\\.\\s/.test(line);\n};\n\n/**\n * Check if a word starts with a character that cannot begin a content line.\n * In thalo syntax, content lines cannot start with:\n * - # (would be parsed as markdown header attempt)\n * - // (would be parsed as a comment)\n */\nconst startsWithProblematicChar = (word: string): boolean => {\n  return word.startsWith(\"#\") || word.startsWith(\"//\");\n};\n\nconst getContentLineText = (node: SyntaxNode): string => {\n  const contentText = node.children.find((c) => c.type === \"content_text\");\n  if (contentText) {\n    return contentText.text.trim();\n  }\n\n  // Fallback: Content line text, trimmed of leading newline/indent and trailing newline\n  // (grammar includes _content_line_start which has the newline+indent)\n  return node.text.replace(/^[\\r\\n\\s]+/, \"\").replace(/[\\r\\n]+$/, \"\");\n};\n\nconst printContentLine = (node: SyntaxNode, _options: ThaloOptions, indent: string): Doc => {\n  return [indent, getContentLineText(node)];\n};\n\nconst formatParagraph = (lines: string[], options: ThaloOptions, indent: string): Doc => {\n  if (lines.length === 0) {\n    return \"\";\n  }\n\n  const proseWrap = options.proseWrap ?? \"preserve\";\n\n  // Check if any line is a list item - if so, preserve each on its own line\n  const hasListItems = lines.some(isListItem);\n  if (hasListItems) {\n    // Group lines into list items: a bullet line and its continuation lines form one item\n    // This ensures stable formatting regardless of how lines were previously wrapped\n    const listItems: string[][] = [];\n    for (const rawLine of lines) {\n      const trimmedLine = rawLine.trim();\n      if (isListItem(trimmedLine)) {\n        // Start a new list item\n        listItems.push([trimmedLine]);\n      } else if (listItems.length > 0) {\n        // Continuation of the current list item\n        listItems[listItems.length - 1].push(trimmedLine);\n      } else {\n        // Non-list line before any list item (prose before the list)\n        listItems.push([trimmedLine]);\n      }\n    }\n\n    // Format each list item\n    const docs: Doc[] = [];\n    for (const [itemIndex, itemLines] of listItems.entries()) {\n      if (itemIndex > 0) {\n        docs.push(hardline);\n      }\n\n      const firstLine = itemLines[0];\n      if (isListItem(firstLine)) {\n        // This is a bullet item - combine all its lines and format as one unit\n        const match = firstLine.match(/^([-*+]\\s|\\d+\\.\\s)(.*)$/);\n        if (match) {\n          const [, marker, firstContent] = match;\n          // Combine bullet content with continuation lines\n          const allContent = [firstContent, ...itemLines.slice(1)]\n            .join(\" \")\n            .replace(/\\s+/g, \" \")\n            .trim();\n          const words = allContent.length > 0 ? allContent.split(/\\s+/) : [];\n\n          if (words.length === 0) {\n            docs.push(indent, marker.trimEnd());\n          } else if (proseWrap === \"always\") {\n            const wordDocs: Doc[] = [];\n            for (const [wordIndex, word] of words.entries()) {\n              if (wordIndex === 0) {\n                wordDocs.push(word);\n              } else if (startsWithProblematicChar(word)) {\n                // Words starting with # or // cannot begin a content line in thalo syntax.\n                // Use a non-breaking space to keep them attached to the previous word.\n                wordDocs.push(\" \", word);\n              } else {\n                wordDocs.push(line, word);\n              }\n            }\n            // Align continuation to after the marker\n            const markerIndent = indent + \" \".repeat(marker.length);\n            docs.push(indent, marker, align(markerIndent, fill(wordDocs)));\n          } else {\n            // For \"never\" or \"preserve\", keep content on one line after the marker\n            docs.push(indent, marker, allContent);\n          }\n        } else {\n          docs.push(indent, firstLine);\n        }\n      } else {\n        // Non-list item (prose that appeared before the first bullet)\n        docs.push(indent, itemLines.join(\" \").replace(/\\s+/g, \" \").trim());\n      }\n    }\n    return docs;\n  }\n\n  const text = lines.join(\" \").replace(/\\s+/g, \" \").trim();\n\n  if (proseWrap === \"never\") {\n    return [indent, text];\n  }\n\n  if (proseWrap === \"always\") {\n    const words = text.length > 0 ? text.split(/\\s+/) : [];\n    if (words.length === 0) {\n      return indent;\n    }\n\n    const wordDocs: Doc[] = [];\n    for (const [index, word] of words.entries()) {\n      if (index === 0) {\n        wordDocs.push(word);\n      } else if (startsWithProblematicChar(word)) {\n        // Words starting with # or // cannot begin a content line in thalo syntax.\n        // Use a non-breaking space to keep them attached to the previous word.\n        wordDocs.push(\" \", word);\n      } else {\n        wordDocs.push(line, word);\n      }\n    }\n\n    // Align wrapped lines to the same indent string. align() accepts a string to\n    // reuse the exact indent (spaces or tabs) rather than a fixed width.\n    return [indent, align(indent, fill(wordDocs))];\n  }\n\n  // preserve\n  const trimmedLines = lines.map((l) => l.trim());\n  const [first, ...rest] = trimmedLines;\n  if (rest.length === 0) {\n    return [indent, first];\n  }\n\n  return [indent, join([hardline, indent], [first, ...rest])];\n};\n\n// ===================\n// Instance Entry Printing (create/update lore, opinion, etc.)\n// ===================\n\n/**\n * Print header fields that are inline in data_entry or schema_entry nodes.\n * The new grammar has header fields directly on the entry node rather than\n * in a separate header child node.\n */\nconst printEntryHeaderFields = (\n  node: SyntaxNode,\n  directiveType: \"data_directive\" | \"schema_directive\",\n): Doc => {\n  const parts: Doc[] = [];\n\n  for (const child of node.children) {\n    if (child.type === \"timestamp\") {\n      parts.push(child.text);\n    } else if (child.type === directiveType) {\n      parts.push(\" \", child.text);\n    } else if (child.type === \"identifier\") {\n      parts.push(\" \", child.text);\n    } else if (child.type === \"title\") {\n      parts.push(\" \", child.text);\n    } else if (child.type === \"link\") {\n      parts.push(\" \", child.text);\n    } else if (child.type === \"tag\") {\n      parts.push(\" \", child.text);\n    }\n  }\n\n  return parts;\n};\n\nconst printMetadata = (node: SyntaxNode, indent: string): Doc => {\n  const key = node.childForFieldName(\"key\");\n  const value = node.childForFieldName(\"value\");\n\n  if (!key || !value) {\n    return \"\";\n  }\n\n  // Trim leading/trailing whitespace from value (grammar may capture spaces)\n  return [indent, key.text, \": \", value.text.trim()];\n};\n\nconst printMarkdownHeader = (node: SyntaxNode, indent: string): Doc => {\n  // Extract hashes and text from the node (new grammar uses md_indicator and md_heading_text)\n  let hashes = \"\";\n  let text = \"\";\n\n  for (const child of node.children) {\n    if (child.type === \"md_indicator\") {\n      hashes = child.text;\n    } else if (child.type === \"md_heading_text\") {\n      text = child.text;\n    }\n  }\n\n  // If we couldn't get structured parts, fall back to reconstructing from text\n  // Note: node.text includes preceding newline from grammar's _content_line_start\n  if (!hashes) {\n    const trimmedText = node.text.replace(/^[\\r\\n\\s]+/, \"\").replace(/[\\r\\n]+$/, \"\");\n    const match = trimmedText.match(/^(#+)\\s*(.*)$/);\n    if (match) {\n      hashes = match[1];\n      text = \" \" + match[2];\n    } else {\n      return [indent, trimmedText.trim()];\n    }\n  }\n\n  // Normalize multiple spaces to single space in header text\n  text = text.replace(/ +/g, \" \");\n\n  return [indent, hashes, text];\n};\n\nconst printCommentLine = (node: SyntaxNode, indent: string): Doc => {\n  // comment_line contains a comment child\n  const comment = node.children.find((c) => c.type === \"comment\");\n  if (comment) {\n    return [indent, comment.text];\n  }\n  // Fallback: extract comment from node text\n  const text = node.text.replace(/^[\\r\\n\\s]+/, \"\").replace(/[\\r\\n]+$/, \"\");\n  return [indent, text];\n};\n\nconst printContent = (\n  node: SyntaxNode,\n  options: ThaloOptions,\n  indent: string,\n  insertBlankLineBeforeContent: boolean,\n): Doc => {\n  const parts: Doc[] = [];\n\n  // Get visible content children (markdown_header, content_line, and comment_line)\n  const contentChildren = node.children.filter(\n    (c) => c.type === \"markdown_header\" || c.type === \"content_line\" || c.type === \"comment_line\",\n  );\n\n  let lastRow = -1;\n  let paragraphLines: string[] = [];\n\n  const flushParagraph = () => {\n    if (paragraphLines.length === 0) {\n      return;\n    }\n    parts.push(hardline, formatParagraph(paragraphLines, options, indent));\n    paragraphLines = [];\n  };\n\n  for (const child of contentChildren) {\n    const currentRow = child.startPosition.row;\n\n    if (lastRow >= 0) {\n      // Check for blank lines between elements by comparing row numbers\n      const rowGap = currentRow - lastRow;\n      if (rowGap > 1) {\n        flushParagraph();\n        // Add blank lines for gaps (rowGap - 1 blank lines)\n        for (let i = 0; i < rowGap - 1; i++) {\n          parts.push(hardline);\n        }\n      }\n    }\n\n    if (child.type === \"markdown_header\") {\n      flushParagraph();\n      parts.push(hardline, printMarkdownHeader(child, indent));\n    } else if (child.type === \"comment_line\") {\n      flushParagraph();\n      parts.push(hardline, printCommentLine(child, indent));\n    } else {\n      paragraphLines.push(getContentLineText(child));\n    }\n\n    lastRow = currentRow;\n  }\n\n  flushParagraph();\n\n  if (parts.length === 0) {\n    return \"\";\n  }\n\n  // `parts` always begins with a `hardline` (because each child is printed as `[hardline, ...]`).\n  // If we want a *blank line* before content, prepend an extra `hardline`.\n  return insertBlankLineBeforeContent ? [hardline, ...parts] : parts;\n};\n\n/**\n * Print a data_entry node (handles create, update, define-synthesis, actualize-synthesis).\n * Header fields are inline on the entry node in the new grammar.\n */\nconst printDataEntry = (node: SyntaxNode, options: ThaloOptions, indent: string): Doc => {\n  const parts: Doc[] = [];\n\n  // Print header fields directly from the entry node\n  parts.push(printEntryHeaderFields(node, \"data_directive\"));\n\n  // Handle metadata and comment_line nodes (they can be interleaved)\n  const metadataAndComments = node.children.filter(\n    (c) => c.type === \"metadata\" || c.type === \"comment_line\",\n  );\n  // If there are any lines between header and content (metadata or indented comments),\n  // keep a blank line before the first section. If there are none, don't insert an\n  // empty line between the header and the first section.\n  const hasHeaderPreludeLines = metadataAndComments.length > 0;\n  for (const child of metadataAndComments) {\n    if (child.type === \"metadata\") {\n      parts.push(hardline, printMetadata(child, indent));\n    } else {\n      parts.push(hardline, printCommentLine(child, indent));\n    }\n  }\n\n  const content = node.children.find((c) => c.type === \"content\");\n  if (content) {\n    // If there is no metadata, don't insert an empty line between the header and the first section.\n    parts.push(printContent(content, options, indent, hasHeaderPreludeLines));\n  }\n\n  return parts;\n};\n\n// ===================\n// Schema Entry Printing (define-entity/alter-entity)\n// ===================\n\nconst printTypeExpression = (node: SyntaxNode): Doc => {\n  const parts: Doc[] = [];\n\n  for (const child of node.children) {\n    if (child.type === \"union_type\") {\n      parts.push(printUnionType(child));\n    } else if (child.type === \"array_type\") {\n      parts.push(printArrayType(child));\n    } else if (child.type === \"primitive_type\") {\n      parts.push(child.text);\n    } else if (child.type === \"literal_type\") {\n      parts.push(child.text);\n    }\n  }\n\n  return parts;\n};\n\nconst printUnionType = (node: SyntaxNode): Doc => {\n  const typeTerms: Doc[] = [];\n\n  for (const child of node.children) {\n    if (child.type === \"array_type\") {\n      typeTerms.push(printArrayType(child));\n    } else if (child.type === \"primitive_type\" || child.type === \"literal_type\") {\n      typeTerms.push(child.text);\n    }\n  }\n\n  return join(\" | \", typeTerms);\n};\n\nconst printArrayType = (node: SyntaxNode): Doc => {\n  for (const child of node.children) {\n    if (child.type === \"primitive_type\" || child.type === \"literal_type\") {\n      return [child.text, \"[]\"];\n    }\n  }\n  return node.text;\n};\n\nconst printFieldDefinition = (node: SyntaxNode, indent: string): Doc => {\n  const parts: Doc[] = [indent];\n\n  // Field name (includes newline+indent in token, extract just the name)\n  const fieldName = node.children.find((c) => c.type === \"field_name\");\n  if (fieldName) {\n    // Extract just the field name from the token (which includes \\n and indent)\n    const nameMatch = fieldName.text.match(/[a-z][a-zA-Z0-9\\-_]*/);\n    if (nameMatch) {\n      parts.push(nameMatch[0]);\n    }\n  }\n\n  // Optional marker\n  const optionalMarker = node.children.find((c) => c.type === \"optional_marker\");\n  if (optionalMarker) {\n    parts.push(\"?\");\n  }\n\n  parts.push(\": \");\n\n  // Type expression\n  const typeExpr = node.childForFieldName(\"type\");\n  if (typeExpr) {\n    parts.push(printTypeExpression(typeExpr));\n  }\n\n  // Default value\n  const defaultValue = node.childForFieldName(\"default\");\n  if (defaultValue) {\n    parts.push(\" = \");\n    const literal = defaultValue.children.find((c) => c.type === \"literal_type\");\n    if (literal) {\n      parts.push(literal.text.trim());\n    } else {\n      parts.push(defaultValue.text.trim());\n    }\n  }\n\n  // Description\n  const description = node.childForFieldName(\"description\");\n  if (description) {\n    parts.push(\" ; \", description.text);\n  }\n\n  return parts;\n};\n\nconst printSectionDefinition = (node: SyntaxNode, indent: string): Doc => {\n  const parts: Doc[] = [indent];\n\n  // Section name (includes newline+indent in token, extract just the name)\n  const sectionName = node.children.find((c) => c.type === \"section_name\");\n  if (sectionName) {\n    // Extract just the section name from the token (which includes \\n and indent)\n    // Section names can have spaces: \"Key Takeaways\", \"Related Items\", etc.\n    // Match allows 1+ spaces between words, then normalize to single space\n    const nameMatch = sectionName.text.match(/[A-Z][a-zA-Z0-9]*(?: +[a-zA-Z0-9]+)*/);\n    if (nameMatch) {\n      // Normalize multiple spaces to single space\n      parts.push(nameMatch[0].replace(/ +/g, \" \"));\n    }\n  }\n\n  // Optional marker\n  const optionalMarker = node.children.find((c) => c.type === \"optional_marker\");\n  if (optionalMarker) {\n    parts.push(\"?\");\n  }\n\n  // Description\n  const description = node.childForFieldName(\"description\");\n  if (description) {\n    parts.push(\" ; \", description.text);\n  }\n\n  return parts;\n};\n\nconst printFieldRemoval = (node: SyntaxNode, indent: string): Doc => {\n  const parts: Doc[] = [indent];\n\n  // Field name\n  const fieldName = node.children.find((c) => c.type === \"field_name\");\n  if (fieldName) {\n    const nameMatch = fieldName.text.match(/[a-z][a-zA-Z0-9\\-_]*/);\n    if (nameMatch) {\n      parts.push(nameMatch[0]);\n    }\n  }\n\n  // Reason (description)\n  const reason = node.childForFieldName(\"reason\");\n  if (reason) {\n    parts.push(\" ; \", reason.text);\n  }\n\n  return parts;\n};\n\nconst printSectionRemoval = (node: SyntaxNode, indent: string): Doc => {\n  const parts: Doc[] = [indent];\n\n  // Section name\n  const sectionName = node.children.find((c) => c.type === \"section_name\");\n  if (sectionName) {\n    // Section names can have spaces: \"Key Takeaways\", \"Related Items\", etc.\n    // Match allows 1+ spaces between words, then normalize to single space\n    const nameMatch = sectionName.text.match(/[A-Z][a-zA-Z0-9]*(?: +[a-zA-Z0-9]+)*/);\n    if (nameMatch) {\n      // Normalize multiple spaces to single space\n      parts.push(nameMatch[0].replace(/ +/g, \" \"));\n    }\n  }\n\n  // Reason (description)\n  const reason = node.childForFieldName(\"reason\");\n  if (reason) {\n    parts.push(\" ; \", reason.text);\n  }\n\n  return parts;\n};\n\nconst printMetadataBlock = (node: SyntaxNode, indent: string): Doc => {\n  const parts: Doc[] = [hardline, indent, \"# Metadata\"];\n\n  const fieldDefs = node.children.filter((c) => c.type === \"field_definition\");\n  for (const field of fieldDefs) {\n    parts.push(hardline, printFieldDefinition(field, indent));\n  }\n\n  return parts;\n};\n\nconst printSectionsBlock = (node: SyntaxNode, indent: string): Doc => {\n  const parts: Doc[] = [hardline, indent, \"# Sections\"];\n\n  const sectionDefs = node.children.filter((c) => c.type === \"section_definition\");\n  for (const section of sectionDefs) {\n    parts.push(hardline, printSectionDefinition(section, indent));\n  }\n\n  return parts;\n};\n\nconst printRemoveMetadataBlock = (node: SyntaxNode, indent: string): Doc => {\n  const parts: Doc[] = [hardline, indent, \"# Remove Metadata\"];\n\n  const fieldRemovals = node.children.filter((c) => c.type === \"field_removal\");\n  for (const removal of fieldRemovals) {\n    parts.push(hardline, printFieldRemoval(removal, indent));\n  }\n\n  return parts;\n};\n\nconst printRemoveSectionsBlock = (node: SyntaxNode, indent: string): Doc => {\n  const parts: Doc[] = [hardline, indent, \"# Remove Sections\"];\n\n  const sectionRemovals = node.children.filter((c) => c.type === \"section_removal\");\n  for (const removal of sectionRemovals) {\n    parts.push(hardline, printSectionRemoval(removal, indent));\n  }\n\n  return parts;\n};\n\n/**\n * Print a schema_entry node (handles define-entity, alter-entity).\n * Header fields are inline on the entry node in the new grammar.\n */\nconst printSchemaEntry = (node: SyntaxNode, _options: ThaloOptions, indent: string): Doc => {\n  const parts: Doc[] = [];\n\n  // Print header fields directly from the entry node\n  parts.push(printEntryHeaderFields(node, \"schema_directive\"));\n\n  // Track whether we've printed a block (for adding blank lines between blocks)\n  let hasBlockBefore = false;\n\n  // Print blocks in order they appear\n  for (const child of node.children) {\n    if (child.type === \"metadata_block\") {\n      parts.push(printMetadataBlock(child, indent));\n      hasBlockBefore = true;\n    } else if (child.type === \"sections_block\") {\n      // Add blank line before # Sections if there's a preceding block\n      if (hasBlockBefore) {\n        parts.push(hardline);\n      }\n      parts.push(printSectionsBlock(child, indent));\n      hasBlockBefore = true;\n    } else if (child.type === \"remove_metadata_block\") {\n      parts.push(printRemoveMetadataBlock(child, indent));\n      hasBlockBefore = true;\n    } else if (child.type === \"remove_sections_block\") {\n      // Add blank line before # Remove Sections if there's a preceding block\n      if (hasBlockBefore) {\n        parts.push(hardline);\n      }\n      parts.push(printRemoveSectionsBlock(child, indent));\n      hasBlockBefore = true;\n    }\n  }\n\n  return parts;\n};\n\n// ===================\n// Entry Printing (dispatches to instance or schema)\n// ===================\n\nconst printEntry = (node: SyntaxNode, options: ThaloOptions, indent: string): Doc => {\n  const dataEntry = node.children.find((c) => c.type === \"data_entry\");\n  if (dataEntry) {\n    return printDataEntry(dataEntry, options, indent);\n  }\n\n  const schemaEntry = node.children.find((c) => c.type === \"schema_entry\");\n  if (schemaEntry) {\n    return printSchemaEntry(schemaEntry, options, indent);\n  }\n\n  // For unhandled entry types, preserve the original text\n  return node.text;\n};\n\nconst printComment = (node: SyntaxNode, indent: string): Doc => {\n  // Use column position to determine if comment was indented\n  const isIndented = node.startPosition.column > 0;\n  return isIndented ? [indent, node.text] : node.text;\n};\n\nconst printUnhandledNode = (node: SyntaxNode): Doc => {\n  // Preserve unhandled nodes exactly as they appear in source\n  return node.text;\n};\n\nconst printSourceFile = (node: SyntaxNode, options: ThaloOptions, indent: string): Doc => {\n  // Check for errors - if present, return original source unchanged\n  // Tree-sitter error recovery can produce structurally broken trees where\n  // content gets detached from its parent entry, losing indentation context.\n  // Safest approach: don't format files with syntax errors.\n  const rootNode = node as ThaloRootNode;\n  if (rootNode._thaloHasErrors) {\n    // Return original source unchanged (with trailing newline for consistency)\n    // The format command handles error reporting, so we don't output anything here.\n    const source = rootNode._thaloSource ?? \"\";\n    return source.endsWith(\"\\n\") ? source : source + \"\\n\";\n  }\n\n  // Get all non-whitespace children\n  const relevantChildren = node.children.filter((c) => c.type !== \"\");\n\n  if (relevantChildren.length === 0) {\n    return \"\";\n  }\n\n  // Build output preserving comments and entries with proper spacing\n  const docs: Doc[] = [];\n  let lastWasEntry = false;\n  let lastWasIndentedComment = false;\n\n  for (const child of relevantChildren) {\n    if (child.type === \"comment\") {\n      const isIndented = child.startPosition.column > 0;\n\n      if (isIndented) {\n        // Indented comment - belongs to preceding entry, no blank line\n        docs.push(hardline, printComment(child, indent));\n        lastWasIndentedComment = true;\n      } else {\n        // Top-level comment - add blank line after entry\n        if (lastWasEntry || lastWasIndentedComment) {\n          docs.push(hardline, hardline);\n        } else if (docs.length > 0) {\n          docs.push(hardline);\n        }\n        docs.push(printComment(child, indent));\n        lastWasIndentedComment = false;\n      }\n      lastWasEntry = false;\n    } else if (child.type === \"entry\") {\n      // Entry - add blank line between entries/after comments\n      if (docs.length > 0) {\n        docs.push(hardline, hardline);\n      }\n      docs.push(printEntry(child, options, indent));\n      lastWasEntry = true;\n      lastWasIndentedComment = false;\n    } else {\n      // Unhandled node type - preserve as-is with proper spacing\n      if (docs.length > 0) {\n        docs.push(hardline, hardline);\n      }\n      docs.push(printUnhandledNode(child));\n      lastWasEntry = true; // Treat as entry for spacing purposes\n      lastWasIndentedComment = false;\n    }\n  }\n\n  return [...docs, hardline];\n};\n\nexport const printer: ThaloPrinter = {\n  print(path: AstPath<SyntaxNode>, options: ThaloOptions, _print): Doc {\n    const node = path.node;\n    const indent = getIndent(options);\n\n    switch (node.type) {\n      case \"source_file\":\n        return printSourceFile(node, options, indent);\n      case \"entry\":\n        return printEntry(node, options, indent);\n      case \"data_entry\":\n        return printDataEntry(node, options, indent);\n      case \"schema_entry\":\n        return printSchemaEntry(node, options, indent);\n      case \"metadata\":\n        return printMetadata(node, indent);\n      case \"content\":\n        return printContent(node, options, indent, true);\n      case \"markdown_header\":\n        return printMarkdownHeader(node, indent);\n      case \"content_line\":\n        return printContentLine(node, options, indent);\n      case \"comment_line\":\n        return printCommentLine(node, indent);\n      case \"comment\":\n        return printComment(node, indent);\n      case \"metadata_block\":\n        return printMetadataBlock(node, indent);\n      case \"sections_block\":\n        return printSectionsBlock(node, indent);\n      case \"remove_metadata_block\":\n        return printRemoveMetadataBlock(node, indent);\n      case \"remove_sections_block\":\n        return printRemoveSectionsBlock(node, indent);\n      case \"field_definition\":\n        return printFieldDefinition(node, indent);\n      case \"section_definition\":\n        return printSectionDefinition(node, indent);\n      case \"field_removal\":\n        return printFieldRemoval(node, indent);\n      case \"section_removal\":\n        return printSectionRemoval(node, indent);\n      case \"type_expression\":\n        return printTypeExpression(node);\n      case \"union_type\":\n        return printUnionType(node);\n      case \"array_type\":\n        return printArrayType(node);\n      default:\n        // For any unhandled node, just return its text\n        return node.text;\n    }\n  },\n};\n"],"mappings":"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"}