import { doc } from "prettier";

//#region src/printer.ts
const { align, fill, hardline, join, line } = doc.builders;
const getIndent = (options) => {
	const tabWidth = typeof options.tabWidth === "number" ? options.tabWidth : 2;
	return options.useTabs ? "	" : " ".repeat(tabWidth);
};
/**
* Detect markdown list items: "- item", "* item", "+ item", "1. item", etc.
*/
const isListItem = (line$1) => {
	return /^[-*+]\s|^\d+\.\s/.test(line$1);
};
/**
* Check if a word starts with a character that cannot begin a content line.
* In thalo syntax, content lines cannot start with:
* - # (would be parsed as markdown header attempt)
* - // (would be parsed as a comment)
*/
const startsWithProblematicChar = (word) => {
	return word.startsWith("#") || word.startsWith("//");
};
const getContentLineText = (node) => {
	const contentText = node.children.find((c) => c.type === "content_text");
	if (contentText) return contentText.text.trim();
	return node.text.replace(/^[\r\n\s]+/, "").replace(/[\r\n]+$/, "");
};
const printContentLine = (node, _options, indent) => {
	return [indent, getContentLineText(node)];
};
const formatParagraph = (lines, options, indent) => {
	if (lines.length === 0) return "";
	const proseWrap = options.proseWrap ?? "preserve";
	if (lines.some(isListItem)) {
		const listItems = [];
		for (const rawLine of lines) {
			const trimmedLine = rawLine.trim();
			if (isListItem(trimmedLine)) listItems.push([trimmedLine]);
			else if (listItems.length > 0) listItems[listItems.length - 1].push(trimmedLine);
			else listItems.push([trimmedLine]);
		}
		const docs = [];
		for (const [itemIndex, itemLines] of listItems.entries()) {
			if (itemIndex > 0) docs.push(hardline);
			const firstLine = itemLines[0];
			if (isListItem(firstLine)) {
				const match = firstLine.match(/^([-*+]\s|\d+\.\s)(.*)$/);
				if (match) {
					const [, marker, firstContent] = match;
					const allContent = [firstContent, ...itemLines.slice(1)].join(" ").replace(/\s+/g, " ").trim();
					const words = allContent.length > 0 ? allContent.split(/\s+/) : [];
					if (words.length === 0) docs.push(indent, marker.trimEnd());
					else if (proseWrap === "always") {
						const wordDocs = [];
						for (const [wordIndex, word] of words.entries()) if (wordIndex === 0) wordDocs.push(word);
						else if (startsWithProblematicChar(word)) wordDocs.push(" ", word);
						else wordDocs.push(line, word);
						const markerIndent = indent + " ".repeat(marker.length);
						docs.push(indent, marker, align(markerIndent, fill(wordDocs)));
					} else docs.push(indent, marker, allContent);
				} else docs.push(indent, firstLine);
			} else docs.push(indent, itemLines.join(" ").replace(/\s+/g, " ").trim());
		}
		return docs;
	}
	const text = lines.join(" ").replace(/\s+/g, " ").trim();
	if (proseWrap === "never") return [indent, text];
	if (proseWrap === "always") {
		const words = text.length > 0 ? text.split(/\s+/) : [];
		if (words.length === 0) return indent;
		const wordDocs = [];
		for (const [index, word] of words.entries()) if (index === 0) wordDocs.push(word);
		else if (startsWithProblematicChar(word)) wordDocs.push(" ", word);
		else wordDocs.push(line, word);
		return [indent, align(indent, fill(wordDocs))];
	}
	const [first, ...rest] = lines.map((l) => l.trim());
	if (rest.length === 0) return [indent, first];
	return [indent, join([hardline, indent], [first, ...rest])];
};
/**
* Print header fields that are inline in data_entry or schema_entry nodes.
* The new grammar has header fields directly on the entry node rather than
* in a separate header child node.
*/
const printEntryHeaderFields = (node, directiveType) => {
	const parts = [];
	for (const child of node.children) if (child.type === "timestamp") parts.push(child.text);
	else if (child.type === directiveType) parts.push(" ", child.text);
	else if (child.type === "identifier") parts.push(" ", child.text);
	else if (child.type === "title") parts.push(" ", child.text);
	else if (child.type === "link") parts.push(" ", child.text);
	else if (child.type === "tag") parts.push(" ", child.text);
	return parts;
};
const printMetadata = (node, indent) => {
	const key = node.childForFieldName("key");
	const value = node.childForFieldName("value");
	if (!key || !value) return "";
	return [
		indent,
		key.text,
		": ",
		value.text.trim()
	];
};
const printMarkdownHeader = (node, indent) => {
	let hashes = "";
	let text = "";
	for (const child of node.children) if (child.type === "md_indicator") hashes = child.text;
	else if (child.type === "md_heading_text") text = child.text;
	if (!hashes) {
		const trimmedText = node.text.replace(/^[\r\n\s]+/, "").replace(/[\r\n]+$/, "");
		const match = trimmedText.match(/^(#+)\s*(.*)$/);
		if (match) {
			hashes = match[1];
			text = " " + match[2];
		} else return [indent, trimmedText.trim()];
	}
	text = text.replace(/ +/g, " ");
	return [
		indent,
		hashes,
		text
	];
};
const printCommentLine = (node, indent) => {
	const comment = node.children.find((c) => c.type === "comment");
	if (comment) return [indent, comment.text];
	return [indent, node.text.replace(/^[\r\n\s]+/, "").replace(/[\r\n]+$/, "")];
};
const printContent = (node, options, indent, insertBlankLineBeforeContent) => {
	const parts = [];
	const contentChildren = node.children.filter((c) => c.type === "markdown_header" || c.type === "content_line" || c.type === "comment_line");
	let lastRow = -1;
	let paragraphLines = [];
	const flushParagraph = () => {
		if (paragraphLines.length === 0) return;
		parts.push(hardline, formatParagraph(paragraphLines, options, indent));
		paragraphLines = [];
	};
	for (const child of contentChildren) {
		const currentRow = child.startPosition.row;
		if (lastRow >= 0) {
			const rowGap = currentRow - lastRow;
			if (rowGap > 1) {
				flushParagraph();
				for (let i = 0; i < rowGap - 1; i++) parts.push(hardline);
			}
		}
		if (child.type === "markdown_header") {
			flushParagraph();
			parts.push(hardline, printMarkdownHeader(child, indent));
		} else if (child.type === "comment_line") {
			flushParagraph();
			parts.push(hardline, printCommentLine(child, indent));
		} else paragraphLines.push(getContentLineText(child));
		lastRow = currentRow;
	}
	flushParagraph();
	if (parts.length === 0) return "";
	return insertBlankLineBeforeContent ? [hardline, ...parts] : parts;
};
/**
* Print a data_entry node (handles create, update, define-synthesis, actualize-synthesis).
* Header fields are inline on the entry node in the new grammar.
*/
const printDataEntry = (node, options, indent) => {
	const parts = [];
	parts.push(printEntryHeaderFields(node, "data_directive"));
	const metadataAndComments = node.children.filter((c) => c.type === "metadata" || c.type === "comment_line");
	const hasHeaderPreludeLines = metadataAndComments.length > 0;
	for (const child of metadataAndComments) if (child.type === "metadata") parts.push(hardline, printMetadata(child, indent));
	else parts.push(hardline, printCommentLine(child, indent));
	const content = node.children.find((c) => c.type === "content");
	if (content) parts.push(printContent(content, options, indent, hasHeaderPreludeLines));
	return parts;
};
const printTypeExpression = (node) => {
	const parts = [];
	for (const child of node.children) if (child.type === "union_type") parts.push(printUnionType(child));
	else if (child.type === "array_type") parts.push(printArrayType(child));
	else if (child.type === "primitive_type") parts.push(child.text);
	else if (child.type === "literal_type") parts.push(child.text);
	return parts;
};
const printUnionType = (node) => {
	const typeTerms = [];
	for (const child of node.children) if (child.type === "array_type") typeTerms.push(printArrayType(child));
	else if (child.type === "primitive_type" || child.type === "literal_type") typeTerms.push(child.text);
	return join(" | ", typeTerms);
};
const printArrayType = (node) => {
	for (const child of node.children) if (child.type === "primitive_type" || child.type === "literal_type") return [child.text, "[]"];
	return node.text;
};
const printFieldDefinition = (node, indent) => {
	const parts = [indent];
	const fieldName = node.children.find((c) => c.type === "field_name");
	if (fieldName) {
		const nameMatch = fieldName.text.match(/[a-z][a-zA-Z0-9\-_]*/);
		if (nameMatch) parts.push(nameMatch[0]);
	}
	if (node.children.find((c) => c.type === "optional_marker")) parts.push("?");
	parts.push(": ");
	const typeExpr = node.childForFieldName("type");
	if (typeExpr) parts.push(printTypeExpression(typeExpr));
	const defaultValue = node.childForFieldName("default");
	if (defaultValue) {
		parts.push(" = ");
		const literal = defaultValue.children.find((c) => c.type === "literal_type");
		if (literal) parts.push(literal.text.trim());
		else parts.push(defaultValue.text.trim());
	}
	const description = node.childForFieldName("description");
	if (description) parts.push(" ; ", description.text);
	return parts;
};
const printSectionDefinition = (node, indent) => {
	const parts = [indent];
	const sectionName = node.children.find((c) => c.type === "section_name");
	if (sectionName) {
		const nameMatch = sectionName.text.match(/[A-Z][a-zA-Z0-9]*(?: +[a-zA-Z0-9]+)*/);
		if (nameMatch) parts.push(nameMatch[0].replace(/ +/g, " "));
	}
	if (node.children.find((c) => c.type === "optional_marker")) parts.push("?");
	const description = node.childForFieldName("description");
	if (description) parts.push(" ; ", description.text);
	return parts;
};
const printFieldRemoval = (node, indent) => {
	const parts = [indent];
	const fieldName = node.children.find((c) => c.type === "field_name");
	if (fieldName) {
		const nameMatch = fieldName.text.match(/[a-z][a-zA-Z0-9\-_]*/);
		if (nameMatch) parts.push(nameMatch[0]);
	}
	const reason = node.childForFieldName("reason");
	if (reason) parts.push(" ; ", reason.text);
	return parts;
};
const printSectionRemoval = (node, indent) => {
	const parts = [indent];
	const sectionName = node.children.find((c) => c.type === "section_name");
	if (sectionName) {
		const nameMatch = sectionName.text.match(/[A-Z][a-zA-Z0-9]*(?: +[a-zA-Z0-9]+)*/);
		if (nameMatch) parts.push(nameMatch[0].replace(/ +/g, " "));
	}
	const reason = node.childForFieldName("reason");
	if (reason) parts.push(" ; ", reason.text);
	return parts;
};
const printMetadataBlock = (node, indent) => {
	const parts = [
		hardline,
		indent,
		"# Metadata"
	];
	const fieldDefs = node.children.filter((c) => c.type === "field_definition");
	for (const field of fieldDefs) parts.push(hardline, printFieldDefinition(field, indent));
	return parts;
};
const printSectionsBlock = (node, indent) => {
	const parts = [
		hardline,
		indent,
		"# Sections"
	];
	const sectionDefs = node.children.filter((c) => c.type === "section_definition");
	for (const section of sectionDefs) parts.push(hardline, printSectionDefinition(section, indent));
	return parts;
};
const printRemoveMetadataBlock = (node, indent) => {
	const parts = [
		hardline,
		indent,
		"# Remove Metadata"
	];
	const fieldRemovals = node.children.filter((c) => c.type === "field_removal");
	for (const removal of fieldRemovals) parts.push(hardline, printFieldRemoval(removal, indent));
	return parts;
};
const printRemoveSectionsBlock = (node, indent) => {
	const parts = [
		hardline,
		indent,
		"# Remove Sections"
	];
	const sectionRemovals = node.children.filter((c) => c.type === "section_removal");
	for (const removal of sectionRemovals) parts.push(hardline, printSectionRemoval(removal, indent));
	return parts;
};
/**
* Print a schema_entry node (handles define-entity, alter-entity).
* Header fields are inline on the entry node in the new grammar.
*/
const printSchemaEntry = (node, _options, indent) => {
	const parts = [];
	parts.push(printEntryHeaderFields(node, "schema_directive"));
	let hasBlockBefore = false;
	for (const child of node.children) if (child.type === "metadata_block") {
		parts.push(printMetadataBlock(child, indent));
		hasBlockBefore = true;
	} else if (child.type === "sections_block") {
		if (hasBlockBefore) parts.push(hardline);
		parts.push(printSectionsBlock(child, indent));
		hasBlockBefore = true;
	} else if (child.type === "remove_metadata_block") {
		parts.push(printRemoveMetadataBlock(child, indent));
		hasBlockBefore = true;
	} else if (child.type === "remove_sections_block") {
		if (hasBlockBefore) parts.push(hardline);
		parts.push(printRemoveSectionsBlock(child, indent));
		hasBlockBefore = true;
	}
	return parts;
};
const printEntry = (node, options, indent) => {
	const dataEntry = node.children.find((c) => c.type === "data_entry");
	if (dataEntry) return printDataEntry(dataEntry, options, indent);
	const schemaEntry = node.children.find((c) => c.type === "schema_entry");
	if (schemaEntry) return printSchemaEntry(schemaEntry, options, indent);
	return node.text;
};
const printComment = (node, indent) => {
	return node.startPosition.column > 0 ? [indent, node.text] : node.text;
};
const printUnhandledNode = (node) => {
	return node.text;
};
const printSourceFile = (node, options, indent) => {
	const rootNode = node;
	if (rootNode._thaloHasErrors) {
		const source = rootNode._thaloSource ?? "";
		return source.endsWith("\n") ? source : source + "\n";
	}
	const relevantChildren = node.children.filter((c) => c.type !== "");
	if (relevantChildren.length === 0) return "";
	const docs = [];
	let lastWasEntry = false;
	let lastWasIndentedComment = false;
	for (const child of relevantChildren) if (child.type === "comment") {
		if (child.startPosition.column > 0) {
			docs.push(hardline, printComment(child, indent));
			lastWasIndentedComment = true;
		} else {
			if (lastWasEntry || lastWasIndentedComment) docs.push(hardline, hardline);
			else if (docs.length > 0) docs.push(hardline);
			docs.push(printComment(child, indent));
			lastWasIndentedComment = false;
		}
		lastWasEntry = false;
	} else if (child.type === "entry") {
		if (docs.length > 0) docs.push(hardline, hardline);
		docs.push(printEntry(child, options, indent));
		lastWasEntry = true;
		lastWasIndentedComment = false;
	} else {
		if (docs.length > 0) docs.push(hardline, hardline);
		docs.push(printUnhandledNode(child));
		lastWasEntry = true;
		lastWasIndentedComment = false;
	}
	return [...docs, hardline];
};
const printer = { print(path, options, _print) {
	const node = path.node;
	const indent = getIndent(options);
	switch (node.type) {
		case "source_file": return printSourceFile(node, options, indent);
		case "entry": return printEntry(node, options, indent);
		case "data_entry": return printDataEntry(node, options, indent);
		case "schema_entry": return printSchemaEntry(node, options, indent);
		case "metadata": return printMetadata(node, indent);
		case "content": return printContent(node, options, indent, true);
		case "markdown_header": return printMarkdownHeader(node, indent);
		case "content_line": return printContentLine(node, options, indent);
		case "comment_line": return printCommentLine(node, indent);
		case "comment": return printComment(node, indent);
		case "metadata_block": return printMetadataBlock(node, indent);
		case "sections_block": return printSectionsBlock(node, indent);
		case "remove_metadata_block": return printRemoveMetadataBlock(node, indent);
		case "remove_sections_block": return printRemoveSectionsBlock(node, indent);
		case "field_definition": return printFieldDefinition(node, indent);
		case "section_definition": return printSectionDefinition(node, indent);
		case "field_removal": return printFieldRemoval(node, indent);
		case "section_removal": return printSectionRemoval(node, indent);
		case "type_expression": return printTypeExpression(node);
		case "union_type": return printUnionType(node);
		case "array_type": return printArrayType(node);
		default: return node.text;
	}
} };

//#endregion
export { printer };
//# sourceMappingURL=printer.js.map